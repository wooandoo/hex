# Autogenerated from a Treetop grammar. Edits may be lost.


require "treetop"

module WOoo
  module Electronics
    module IntelHex
      include Treetop::Runtime

      def root
        @root ||= :file
      end

      module File0
        def _lines
          elements[0]
        end

        def eof_line
          elements[1]
        end
      end

      module File1
        def eval
          data = ""
          _lines.elements.each do |line|
            data += line.eval
          end
          data
        end
      end

      def _nt_file
        start_index = index
        if node_cache[:file].has_key?(index)
          cached = node_cache[:file][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        s1, i1 = [], index
        loop do
          r2 = _nt_data_line
          if r2
            s1 << r2
          else
            break
          end
        end
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        s0 << r1
        if r1
          r3 = _nt_eof_line
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(File0)
          r0.extend(File1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:file][start_index] = r0

        r0
      end

      module DataLine0
        def _byte_count
          elements[2]
        end

        def _address
          elements[3]
        end

        def _record_type
          elements[4]
        end

        def _data
          elements[5]
        end

        def _checksum
          elements[6]
        end

      end

      module DataLine1
        def eval
          line_data = _data.text_value
          # unless line_data.size == 
        end
      end

      def _nt_data_line
        start_index = index
        if node_cache[:data_line].has_key?(index)
          cached = node_cache[:data_line][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_eof_line
        if r2
          r1 = nil
        else
          @index = i1
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if has_terminal?(":", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(":")
            r3 = nil
          end
          s0 << r3
          if r3
            r4 = _nt_byte_count
            s0 << r4
            if r4
              r5 = _nt_address
              s0 << r5
              if r5
                r6 = _nt_record_type
                s0 << r6
                if r6
                  r7 = _nt_data
                  s0 << r7
                  if r7
                    r8 = _nt_checksum
                    s0 << r8
                    if r8
                      if has_terminal?("\n", false, index)
                        r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
                        @index += 1
                      else
                        terminal_parse_failure("\n")
                        r9 = nil
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DataLine0)
          r0.extend(DataLine1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:data_line][start_index] = r0

        r0
      end

      module ByteCount0
        def hex_value1
          elements[0]
        end

        def hex_value2
          elements[1]
        end
      end

      def _nt_byte_count
        start_index = index
        if node_cache[:byte_count].has_key?(index)
          cached = node_cache[:byte_count][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_hex_value
        s0 << r1
        if r1
          r2 = _nt_hex_value
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ByteCount0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:byte_count][start_index] = r0

        r0
      end

      module Address0
        def hex_value1
          elements[0]
        end

        def hex_value2
          elements[1]
        end

        def hex_value3
          elements[2]
        end

        def hex_value4
          elements[3]
        end
      end

      def _nt_address
        start_index = index
        if node_cache[:address].has_key?(index)
          cached = node_cache[:address][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_hex_value
        s0 << r1
        if r1
          r2 = _nt_hex_value
          s0 << r2
          if r2
            r3 = _nt_hex_value
            s0 << r3
            if r3
              r4 = _nt_hex_value
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Address0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:address][start_index] = r0

        r0
      end

      module RecordType0
        def hex_value1
          elements[0]
        end

        def hex_value2
          elements[1]
        end
      end

      def _nt_record_type
        start_index = index
        if node_cache[:record_type].has_key?(index)
          cached = node_cache[:record_type][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_hex_value
        s0 << r1
        if r1
          r2 = _nt_hex_value
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RecordType0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:record_type][start_index] = r0

        r0
      end

      module Data0
        def hex_value
          elements[0]
        end

      end

      def _nt_data
        start_index = index
        if node_cache[:data].has_key?(index)
          cached = node_cache[:data][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          r2 = _nt_hex_value
          s1 << r2
          if r2
            i3 = index
            r4 = _nt_checksum
            if r4
              @index = i3
              r3 = instantiate_node(SyntaxNode,input, index...index)
            else
              r3 = nil
            end
            s1 << r3
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Data0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:data][start_index] = r0

        r0
      end

      module Checksum0
        def hex_value1
          elements[0]
        end

        def hex_value2
          elements[1]
        end
      end

      def _nt_checksum
        start_index = index
        if node_cache[:checksum].has_key?(index)
          cached = node_cache[:checksum][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_hex_value
        s0 << r1
        if r1
          r2 = _nt_hex_value
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Checksum0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:checksum][start_index] = r0

        r0
      end

      def _nt_hex_value
        start_index = index
        if node_cache[:hex_value].has_key?(index)
          cached = node_cache[:hex_value][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if has_terminal?('\G[0-9]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          r0 = r1
        else
          if has_terminal?('\G[A-F]', true, index)
            r2 = true
            @index += 1
          else
            r2 = nil
          end
          if r2
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:hex_value][start_index] = r0

        r0
      end

      def _nt_eof_line
        start_index = index
        if node_cache[:eof_line].has_key?(index)
          cached = node_cache[:eof_line][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(":00000001FF", false, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 11))
          @index += 11
        else
          terminal_parse_failure(":00000001FF")
          r0 = nil
        end

        node_cache[:eof_line][start_index] = r0

        r0
      end

    end

    class IntelHexParser < Treetop::Runtime::CompiledParser
      include IntelHex
    end

  end
end